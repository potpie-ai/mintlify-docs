---
title: 'Post Message'
openapi: 'POST /api/v1/conversations/{conversation_id}/message/'
---

## Overview

Send a message to an existing conversation. The AI agent will process your message based on the conversation context, selected agents, and codebase knowledge graph to provide intelligent responses.

## Use Cases

- Ask questions about your codebase
- Request debugging assistance
- Get explanations of code functionality
- Ask for code improvements or refactoring suggestions
- Request test generation
- Inquire about code relationships and dependencies

## Path Parameters

- **conversation_id**: The unique identifier of the conversation (obtained from Create Conversation endpoint)

## Request Body

### Required Fields

- **content**: Your message or question (string)

### Optional Fields

- **node_ids**: Array of specific code nodes to reference in your question
  - Each node contains:
    - `node_id`: Unique identifier of the code element
    - `name`: Name of the code element (function, class, etc.)

## Node Context

Providing `node_ids` helps the agent focus on specific parts of your codebase:

```json
{
  "content": "How does this authentication function work?",
  "node_ids": [
    {
      "node_id": "node_123",
      "name": "AuthService.authenticate"
    },
    {
      "node_id": "node_456",
      "name": "TokenValidator"
    }
  ]
}
```

<Tip>
  You can find node IDs by using the [Search Codebase](/api-reference/endpoint/search-codebase) endpoint or through the Potpie UI.
</Tip>

## Response

The response indicates message processing status:
- **message_id**: Unique identifier for the sent message
- **status**: Processing state ("processing", "completed", "failed")

<Note>
  The actual AI response is delivered asynchronously. You can retrieve it using the Get Conversation Messages endpoint.
</Note>

## Example Usage

### Basic Question

```javascript
const response = await fetch(
  'https://production-api.potpie.ai/api/v1/conversations/conv_789/message/',
  {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer YOUR_API_KEY',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      content: 'How does the authentication flow work in this codebase?'
    })
  }
);

const data = await response.json();
console.log(`Message sent: ${data.message_id}`);
```

### With Specific Code Context

```python
import requests

# Send message referencing specific code nodes
response = requests.post(
    'https://production-api.potpie.ai/api/v1/conversations/conv_789/message/',
    headers={
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
    },
    json={
        'content': 'Can you explain how these components interact?',
        'node_ids': [
            {
                'node_id': 'node_123',
                'name': 'AuthService'
            },
            {
                'node_id': 'node_456',
                'name': 'UserController'
            }
        ]
    }
)

result = response.json()
print(f"Message ID: {result['message_id']}")
```

### Debugging Workflow

```typescript
// Complete debugging workflow
async function debugWithAgent(conversationId: string, errorMessage: string) {
  // 1. Send initial error message
  const response = await fetch(
    `https://production-api.potpie.ai/api/v1/conversations/${conversationId}/message/`,
    {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        content: `I'm getting this error: ${errorMessage}. Can you help debug it?`
      })
    }
  );

  const { message_id } = await response.json();
  console.log(`Debugging request sent: ${message_id}`);

  // 2. Follow up with more context
  await new Promise(resolve => setTimeout(resolve, 5000)); // Wait for AI response

  const followUpResponse = await fetch(
    `https://production-api.potpie.ai/api/v1/conversations/${conversationId}/message/`,
    {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        content: 'Here are the steps I tried: 1. Checked database connection 2. Verified API credentials'
      })
    }
  );

  return followUpResponse.json();
}
```

## Message Types

Different message patterns for different tasks:

### Question & Answer

```
"What does the parseUserData function do?"
"Where is the JWT token validated?"
"How are database migrations handled?"
```

### Debugging

```
"I'm getting 'TypeError: Cannot read property...' in UserService"
"Why is the authentication failing for OAuth users?"
"The cache is not invalidating properly, can you investigate?"
```

### Code Review

```
"Review the error handling in the payment service"
"Is the API endpoint properly secured?"
"Suggest improvements for the authentication middleware"
```

### Test Generation

```
"Generate unit tests for the UserService class"
"What edge cases should I test for the payment flow?"
"Create integration tests for the authentication endpoints"
```

## Response Streaming

For real-time responses, agents may stream their output. The message status will update as the agent processes:

1. **processing**: Agent is analyzing your question
2. **completed**: Response is ready
3. **failed**: An error occurred

## Best Practices

<CardGroup cols={2}>
  <Card title="Be Specific" icon="bullseye">
    Provide clear context and specific questions for better responses
  </Card>
  <Card title="Reference Code" icon="code">
    Use node_ids to focus the agent on specific code sections
  </Card>
  <Card title="Iterative Debugging" icon="rotate">
    Have back-and-forth conversations for complex issues
  </Card>
  <Card title="Context Matters" icon="layer-group">
    Previous messages in the conversation provide context
  </Card>
</CardGroup>

## Error Handling

```typescript
async function sendMessageSafely(conversationId: string, content: string) {
  try {
    const response = await fetch(
      `https://production-api.potpie.ai/api/v1/conversations/${conversationId}/message/`,
      {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer YOUR_API_KEY',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ content })
      }
    );

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Failed to send message:', error);
    throw error;
  }
}
```

## Rate Limits

- Maximum message length: 10,000 characters
- Rate limit: 10 messages per minute per conversation
- Maximum concurrent conversations: 5 per user

## Next Steps

After sending a message:
1. Wait for processing to complete
2. Retrieve the response using Get Conversation Messages
3. Continue the conversation based on the agent's response
4. Reference the agent's suggestions in follow-up messages
